Я запутался во всех этих идиотских сигналах, мьютексах, деадлоках и прочих весёлых багах. Начнём сначала.

Поток B рисует в back-buffer, параллельно с ним поток F делает вызов drm с front-buffer. Как только они ОБА закончили, надо сделать swap буферов, и затем каждый продолжает работать со своим буфером. Кто главный? Никто. Оба могут обгонять друг друга, ждать друг друга.

Допустим, стартовая временнАя точка - когда закончен свап. После этого потоки работают параллельно и могут завершить работу в любом порядке. Как сделать, чтобы потоки ждали друг друга, после этого один из них выполнял какое-то действие, а другой ждал завершения? ПРИЧЁМ, просто использовать сигналы нельзя - допустим, поток F выполняет свап буферов и шлёт сигнал, а поток B ждёт сигнала. Но что если планировщик сначала запустит F, который полностью отработает и пошлёт сигнал, а поток B ещё не успел начать слушать этот сигнал? По стандарту - UB. На практике - зависание/аварийное завершение.

Какие есть альтернативы? Спинлок. Для свапа буферов подходит, так как буквально пара чтений и пара записей в память плюс синхронизация (если надо). НО. Для ожидания после draw/drm не очень хорошо - разбазариваем процессорное время, а оно при загрузке и так ценное.

Есть другая идея. Две переменные - f_ready, b_ready. Как только поток завершился, ставит свою переменную в 1. Сбрасываются в 0 они при свапе буферов, то есть только ОДНИМ потоком и АТОМАРНО. Допустим, поток F закончил все свои дела раньше B. Он ставит f_ready = 1 и проверяет b_ready. Если она равна 0, значит B ещё работает и ждёт F. Отлично, ждём сигнал от B. Позже, B видит, что f_ready = 1 и посылает сигнал потоку F. Профит. Забыл упомянуть, все операции с f_ready и b_ready проводим ТОЛЬКО под мьютексом. Иначе, если F и B закончат одновременно, будет бардак, неразбериха, вирусы, трояны, взрыв ПК, зомби-апокалипсис и ещё хрен знает что. Вот так то.

Чем дальше в лес, тем толще партизаны. Надо как-то проверять переменную stopped. Есессно, как только 1 поток увидел, что stopped = 1 и вышел из чата, второй должен незамедлительно последовать за ним. Допустим, поток F проверяет переменную перед свапом в мьютексе. А поток B когда? Сразу после получения сигнала? А если случится кэш процессора? А если прерывание прилетит ровненько между получением сигнала и проверкой? Для B stopped равен 1, а для F пару миллисекунд назад stopped был равен 0. Опять двадцать пять. Окей, пусть F проверяет stopped, а потом специально ставит для B другую волатильную переменную. Тогда B сразу увидит её и выйдет.

Так, остался только 1 вопрос. Где sleep и кто будет его делать? А? Пушкин? Любой из потоков, полагаю. Сразу после draw либо вызова drm. Это по сути как часть работы - просто подождать.

Штощ. Какие переменные нам понадобятся? Один pthread_cond_t для ожидания с моря погоды. Один мьютекс для него. Один мьютекс для f_ready и b_ready (но это не точно). И одна переменная для спинлока.


UPD. Есть идея как исправить мигание. Тройная буферизация. Всё просто: в drm меняем с front1 на front2, рендерим в back. Что имеем при синхронизации? В libdrm сейчас кадр front2, его надо поменять на новый кадр (back). В front1 будем отрисовывать. Получается соответствие:

предыдущий кадр    front1    front2    back
следующий кадр     back      front1    front2
